
'use server';
/**
 * @fileOverview An AI agent that answers student questions using a chatbot interface.
 *
 * - answerQuestionWithAIChatbot - A function that handles the question answering process.
 * - AnswerQuestionWithAIChatbotInput - The input type for the answerQuestionWithAIChatbot function.
 * - AnswerQuestionWithAIChatbotOutput - The return type for the answerQuestionWithAIChatbot function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

const AnswerQuestionWithAIChatbotInputSchema = z.object({
  question: z.string().describe('The question to be answered by the chatbot.'),
  userId: z.string().describe('The ID of the user asking the question.'),
  fileDataUri: z.string().optional().describe('An optional file (image or PDF) encoded as a Data URI.'),
});
export type AnswerQuestionWithAIChatbotInput = z.infer<typeof AnswerQuestionWithAIChatbotInputSchema>;

const AnswerQuestionWithAIChatbotOutputSchema = z.object({
  answer: z.string().describe('The answer generated by the AI chatbot.'),
});
export type AnswerQuestionWithAIChatbotOutput = z.infer<typeof AnswerQuestionWithAIChatbotOutputSchema>;

// Helper to convert Data URI to Blob and get file extension
const dataUriToBlob = (dataUri: string): { blob: Blob; extension: string } => {
  const mimeString = dataUri.split(',')[0].split(':')[1].split(';')[0];
  const byteString = atob(dataUri.split(',')[1]);
  const ab = new ArrayBuffer(byteString.length);
  const ia = new Uint8Array(ab);
  for (let i = 0; i < byteString.length; i++) {
    ia[i] = byteString.charCodeAt(i);
  }
  const blob = new Blob([ab], { type: mimeString });
  
  // Basic mapping from MIME type to file extension
  const extension = mimeString.split('/')[1] || 'bin';

  return { blob, extension };
};

export async function answerQuestionWithAIChatbot(input: AnswerQuestionWithAIChatbotInput): Promise<AnswerQuestionWithAIChatbotOutput> {
  const renderApiBaseUrl = process.env.RENDER_AI_API_BASE_URL;

  if (!renderApiBaseUrl) {
    console.error("RENDER_AI_API_BASE_URL is not set in .env file.");
    return { answer: "La connexion au système IA externe n'est pas configurée. Veuillez définir les variables d'environnement nécessaires." };
  }

  try {
    let response;
    let result;

    if (input.fileDataUri) {
      // Endpoint /upload_and_analyze for files
      const fullApiUrl = new URL('/upload_and_analyze', renderApiBaseUrl).toString();
      const { blob, extension } = dataUriToBlob(input.fileDataUri);

      const formData = new FormData();
      // Use a generic filename but with the correct extension
      formData.append('file', blob, `uploaded_file.${extension}`);
      formData.append('user_id', input.userId);
      formData.append('publish_to_kb', 'true');
      if (input.question) {
        formData.append('message', input.question);
      }

      response = await fetch(fullApiUrl, {
        method: 'POST',
        body: formData,
        // No 'Content-Type' header, fetch sets it automatically for FormData
      });

      if (!response.ok) {
        const errorBody = await response.text();
        throw new Error(`API request failed with status ${response.status}: ${errorBody}`);
      }

      const uploadResult = await response.json();
      
      const answer = uploadResult.analysis || uploadResult.answer || "Le fichier a été analysé, mais aucune réponse textuelle n'a été générée.";
      result = { answer };

    } else {
      // Endpoint /chat for text-only
      const renderApiPath = process.env.RENDER_AI_API_PATH || '/chat';
      const fullApiUrl = new URL(renderApiPath, renderApiBaseUrl).toString();

      const payload = {
        question: input.question,
        user_id: input.userId,
        language_preference: 'ar',
      };

      response = await fetch(fullApiUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
      });

      if (!response.ok) {
        const errorBody = await response.text();
        throw new Error(`API request failed with status ${response.status}: ${errorBody}`);
      }
      result = await response.json();
    }
    
    return AnswerQuestionWithAIChatbotOutputSchema.parse(result);

  } catch (error: any) {
    console.error("Error calling external AI system:", error);
    return { answer: `Désolé, une erreur est survenue lors de la communication avec le système IA. (${error.message})` };
  }
}


// The original Genkit flow is kept below for reference but is no longer used by the function above.

const prompt = ai.definePrompt({
  name: 'answerQuestionWithAIChatbotPrompt',
  input: {schema: AnswerQuestionWithAIChatbotInputSchema},
  output: {schema: AnswerQuestionWithAIChatbotOutputSchema},
  prompt: `You are a helpful AI chatbot assisting students with their studies.

  Answer the following question to the best of your ability:

  Question: {{{question}}}`,
});

const answerQuestionWithAIChatbotFlow = ai.defineFlow(
  {
    name: 'answerQuestionWithAIChatbotFlow',
    inputSchema: AnswerQuestionWithAIChatbotInputSchema,
    outputSchema: AnswerQuestionWithAIChatbotOutputSchema,
  },
  async input => {
    const {output} = await prompt(input);
    return output!;
  }
);
