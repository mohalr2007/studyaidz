
'use server';
/**
 * @fileOverview An AI agent that answers student questions using a chatbot interface.
 *
 * - answerQuestionWithAIChatbot - A function that handles the question answering process.
 * - AnswerQuestionWithAIChatbotInput - The input type for the answerQuestionWithAIChatbot function.
 * - AnswerQuestionWithAIChatbotOutput - The return type for the answerQuestionWithAIChatbot function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

const AnswerQuestionWithAIChatbotInputSchema = z.object({
  question: z.string().describe('The question to be answered by the chatbot.'),
  userId: z.string().describe('The ID of the user asking the question.'),
  fileDataUri: z.string().optional().describe('An optional file (image or PDF) encoded as a Data URI.'),
});
export type AnswerQuestionWithAIChatbotInput = z.infer<typeof AnswerQuestionWithAIChatbotInputSchema>;

const AnswerQuestionWithAIChatbotOutputSchema = z.object({
  answer: z.string().describe('The answer generated by the AI chatbot.'),
});
export type AnswerQuestionWithAIChatbotOutput = z.infer<typeof AnswerQuestionWithAIChatbotOutputSchema>;

// Helper to convert Data URI to Blob and get file extension
const dataUriToBlob = (dataUri: string): { blob: Blob; extension: string } => {
  const mimeString = dataUri.split(',')[0].split(':')[1].split(';')[0];
  const byteString = atob(dataUri.split(',')[1]);
  const ab = new ArrayBuffer(byteString.length);
  const ia = new Uint8Array(ab);
  for (let i = 0; i < byteString.length; i++) {
    ia[i] = byteString.charCodeAt(i);
  }
  const blob = new Blob([ab], { type: mimeString });
  
  // Basic mapping from MIME type to file extension
  const extension = mimeString.split('/')[1] || 'bin';

  return { blob, extension };
};

export async function answerQuestionWithAIChatbot(input: AnswerQuestionWithAIChatbotInput): Promise<AnswerQuestionWithAIChatbotOutput> {
  const renderApiBaseUrl = process.env.RENDER_AI_API_BASE_URL;

  if (!renderApiBaseUrl) {
    console.error("RENDER_AI_API_BASE_URL is not set.");
    return { answer: "Erreur de configuration: URL de l'API manquante." };
  }

  try {
    let response;
    
    // CAS 1 : Si on a une image/fichier -> Utiliser /upload_and_analyze (FormData)
    if (input.fileDataUri) {
        const uploadUrl = new URL("/upload_and_analyze", renderApiBaseUrl).toString();
        const formData = new FormData();

        // Conversion du Data URI en Blob pour l'envoi
        const { blob, extension } = dataUriToBlob(input.fileDataUri);
        
        formData.append("file", blob, `uploaded_file.${extension}`); // Nom de fichier dynamique
        formData.append("user_id", input.userId);
        formData.append("publish_to_kb", "true"); 
        
        if (input.question) {
            formData.append("message", input.question);
        }

        response = await fetch(uploadUrl, {
            method: 'POST',
            body: formData, // Pas de Content-Type manuel, fetch le gère pour FormData
        });

    } 
    // CAS 2 : Texte seulement -> Utiliser /chat (JSON)
    else {
        const chatUrl = new URL("/chat", renderApiBaseUrl).toString();
        const payload = {
            user_id: input.userId,
            question: input.question,
            language_preference: "fr"
        };

        response = await fetch(chatUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(payload),
        });
    }

    if (!response.ok) {
        const text = await response.text();
        throw new Error(`Erreur API (${response.status}): ${text}`);
    }

    const result = await response.json();
    
    // Le backend renvoie soit "answer" (chat) soit "analysis" (upload)
    // On normalise tout dans "answer" pour le frontend
    const finalAnswer = result.answer || result.analysis || "Aucune réponse reçue.";

    return { answer: finalAnswer };

  } catch (error: any) {
    console.error("Erreur IA:", error);
    return { answer: `Erreur technique: ${error.message}` };
  }
}


// The original Genkit flow is kept below for reference but is no longer used by the function above.

const prompt = ai.definePrompt({
  name: 'answerQuestionWithAIChatbotPrompt',
  input: {schema: AnswerQuestionWithAIChatbotInputSchema},
  output: {schema: AnswerQuestionWithAIChatbotOutputSchema},
  prompt: `You are a helpful AI chatbot assisting students with their studies.

  Answer the following question to the best of your ability:

  Question: {{{question}}}`,
});

const answerQuestionWithAIChatbotFlow = ai.defineFlow(
  {
    name: 'answerQuestionWithAIChatbotFlow',
    inputSchema: AnswerQuestionWithAIChatbotInputSchema,
    outputSchema: AnswerQuestionWithAIChatbotOutputSchema,
  },
  async input => {
    const {output} = await prompt(input);
    return output!;
  }
);
